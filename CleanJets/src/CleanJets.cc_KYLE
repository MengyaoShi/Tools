// -*- C++ -*-
//
// Package:    CleanJets
// Class:      CleanJets
// 
/**\class CleanJets CleanJets.cc BoostedTauAnalysis/CleanJets/src/CleanJets.cc

 Description: Removes PF muons from PFJet candidates and reconstructs the jets
              Matches those PF muons to muons from a --> tau --> muon decays
              Studies the kinematic properties of the discarded muons
	      Associates those muons to the jets from which they were removed

 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Francesca Ricci-Tam,6 R-025,+41227672274,
//         Created:  Fri Aug 31 13:01:48 CEST 2012
// $Id: CleanJets.cc,v 1.6 2012/12/06 17:44:58 yohay Exp $
//
//


// system include files
#include <memory>
#include <string>
#include <sstream>
#include <fstream>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDProducer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/TauReco/interface/PFTauFwd.h"
#include "DataFormats/TauReco/interface/PFTauDiscriminator.h"
#include "DataFormats/MuonReco/interface/MuonFwd.h"
#include "DataFormats/MuonReco/interface/Muon.h"
#include "DataFormats/MuonReco/interface/MuonSelectors.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "Tools/Common/interface/Common.h"
#include "Tools/Common/interface/GenTauDecayID.h"
#include "DataFormats/Candidate/interface/Particle.h"
#include "DataFormats/Candidate/interface/Candidate.h"
#include "DataFormats/Candidate/interface/CandidateFwd.h"
#include "DataFormats/Math/interface/deltaR.h"
#include "DataFormats/TauReco/interface/PFTauTagInfo.h"
#include "DataFormats/TauReco/interface/PFTauDecayMode.h"
#include "DataFormats/TauReco/interface/PFTauDecayModeAssociation.h"
#include "DataFormats/TauReco/interface/PFTau.h"
#include "DataFormats/TauReco/interface/PFTauFwd.h"
#include "DataFormats/JetReco/interface/PFJet.h"
#include "DataFormats/JetReco/interface/PFJetCollection.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "TH1.h"
#include "TLorentzVector.h"
#include "TGraphAsymmErrors.h"
#include "TMath.h"

using namespace edm;
using namespace reco;
using namespace std;


//
// class declaration
//

class CleanJets : public edm::EDProducer {
   public:
      explicit CleanJets(const edm::ParameterSet&);
      ~CleanJets();

      static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);

   private:
      virtual void beginJob() ;
      virtual void produce(edm::Event&, const edm::EventSetup&);
      virtual void endJob() ;
      
      virtual void beginRun(edm::Run&, edm::EventSetup const&);
      virtual void endRun(edm::Run&, edm::EventSetup const&);
      virtual void beginLuminosityBlock(edm::LuminosityBlock&, edm::EventSetup const&);
      virtual void endLuminosityBlock(edm::LuminosityBlock&, edm::EventSetup const&);

      // ----------member data ---------------------------

      // source of the jets to be cleaned of muons
      edm::EDGetTokenT<PFJetCollection> jetSrc_;

      // source of muons that, if found within jet, should be removed
      edm::EDGetTokenT<MuonRefVector> muonSrc_;

      // source of muons that, if found within jet, should be removed
      edm::EDGetTokenT<vector<reco::Muon> > baseMuonSrc_;

      // source of PF candidates
      edm::EDGetTokenT<PFCandidateCollection> PFCandSrc_;

      // gen Particles
      edm::EDGetTokenT<reco::GenParticleCollection> genParticleTag_;

      //input, output
      TFile* out_;
      std::string outFileName_;
      edm::ParameterSet* cfg_;
      bool debug_;

      //Histograms
      TH1F* NEvents_;
      TH1F* DiMudR_;
      TH1F* NMu_;
      TH1F* MuEnergy_;
      TH1F* MuEnergyA1_;
      TH2F* DiffJetEvsMuonE_;
      TH2F* JetEtavsMuEta_;
      TH2F* JetConstBeforevsAfter_;
      TH1F* DiffConstituents_;
      TH1F* JetMassBefore_;
      TH1F* IfRemovedMu_;
      TH1F* TauJetRemovedPt_;
      TH1F* AJetRemovedPt_;
      TH1F* TauJetMuPt_;
      TH1F* AJetMuPt_;
      TH1F* TauJetMuClosestMudR_;
      TH1F* AJetMuClosestMudR_;
      TH1F* TauJetRemovedPtFraction_;
      TH1F* AJetRemovedPtFraction_;
};

//
// constants, enums and typedefs
//


//
// static data member definitions
//

//
// constructors and destructor
//
CleanJets::CleanJets(const edm::ParameterSet& iConfig):
  jetSrc_(consumes<PFJetCollection>(iConfig.getParameter<edm::InputTag>("jetSrc"))),
  muonSrc_(consumes<MuonRefVector>(iConfig.getParameter<edm::InputTag>("muonSrc"))),
  baseMuonSrc_(consumes<vector<reco::Muon> >(iConfig.getParameter<edm::InputTag>("baseMuonSrc"))),
  PFCandSrc_(consumes<PFCandidateCollection>(iConfig.getParameter<edm::InputTag>("PFCandSrc"))),
  genParticleTag_(consumes<reco::GenParticleCollection>(iConfig.getParameter<edm::InputTag>("genParticleTag"))),
  outFileName_(iConfig.getParameter<std::string>("outFileName"))
{
  cfg_ = const_cast<edm::ParameterSet*>(&iConfig);
  debug_ = true; //set to true if you want to draw validation histograms

  //register your products
  produces<PFJetCollection>( "ak4PFJetsNoMu" );
  produces<edm::ValueMap<bool> >("valMap" );
  produces<edm::ValueMap<MuonRefVector> >( );
  produces<edm::ValueMap<PFJetRef> >( );
  produces<PFCandidateCollection>();
  
}


CleanJets::~CleanJets()
{
 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

}


//
// member functions
//

// ------------ method called to produce the data  ------------
void
CleanJets::produce(edm::Event& iEvent, const edm::EventSetup& iSetup)
{
   std::cout<<"<---------------------------In CleanJets------------------------>" << std::endl;
   NEvents_->Fill(0);
   Handle<PFJetCollection> PFJets;
   iEvent.getByToken(jetSrc_, PFJets);
   auto_ptr<PFJetCollection> SetOfJets( new PFJetCollection );

   Handle<MuonRefVector> muons;
   iEvent.getByToken(muonSrc_, muons);

   Handle<vector<reco::Muon> > baseMuons;
   iEvent.getByToken(baseMuonSrc_, baseMuons);

   double smallestDiMudR = 1000000, RecoMu1PairEta = 1000, RecoMu2PairEta = 1000, RecoMu1PairPhi = 1000, RecoMu2PairPhi = 1000;
   for (vector<reco::Muon>::const_iterator iMuon1 = baseMuons->begin(); iMuon1 != baseMuons->end(); ++iMuon1)
   {
     vector<reco::Muon>::const_iterator iMuonTEMP = iMuon1;
     iMuonTEMP++;
     for (vector<reco::Muon>::const_iterator iMuon2 = iMuonTEMP; iMuon2 != baseMuons->end(); ++iMuon2)
     {
       double dPhiDiMu = reco::deltaPhi(iMuon1->phi(), iMuon2->phi()), dEtaDiMu = iMuon1->eta() - iMuon2->eta(), dRDiMu = sqrt(dPhiDiMu*dPhiDiMu + dEtaDiMu*dEtaDiMu);       
       if (dRDiMu < smallestDiMudR && dRDiMu < .6)
       {
	 smallestDiMudR = dRDiMu;
	 RecoMu1PairEta = iMuon1->eta();
         RecoMu1PairPhi = iMuon1->phi();
         RecoMu2PairEta = iMuon2->eta();
         RecoMu2PairPhi = iMuon2->phi();
       }//if
     }//iMuon2
   }//for iMuon1


   Handle<PFCandidateCollection> PFCands;
   iEvent.getByToken(PFCandSrc_, PFCands);
   auto_ptr<PFCandidateCollection> PFCandsExcludingSoftMuons(new PFCandidateCollection);

   //Get gen particle collection
   edm::Handle<reco::GenParticleCollection> pGenParts;
   iEvent.getByToken(genParticleTag_, pGenParts);

  reco::GenParticleRef mu1Ref, mu2Ref, tau1Ref, tau2Ref;
  bool tau1DecayMode = false, tau2DecayMode = false;
  for (reco::GenParticleCollection::const_iterator iGenParticle = pGenParts->begin(); iGenParticle != pGenParts->end(); ++iGenParticle)
  {
    if(iGenParticle->pdgId() == 36 && iGenParticle->numberOfDaughters() == 2 && fabs(iGenParticle->daughter(0)->pdgId() ) == 15 )
    { 
      tau1Ref = iGenParticle->daughterRef(0);
      tau2Ref = iGenParticle->daughterRef(1);
      unsigned int i1 = 0, i2 = 0;
      bool found1 = false, found2 = false;
      while (!found1)
      {
        found1 = true;
        while (i1 < tau1Ref->numberOfDaughters() )
        {
          reco::GenParticleRef childRef = tau1Ref->daughterRef(i1);
          std::cout << "\ttau1Ref child #" << i1 << " has pdgId= " << fabs(childRef->pdgId()) << std::endl;
          if (fabs(childRef->pdgId()) == 15)
          { 
            tau1Ref = childRef->daughterRef(i1);
            found1 = false;
            break;
          }//if fabs
          if (fabs(childRef->pdgId()) == 13)
            tau1DecayMode = true;
          i1++;
        }//while i1
      }//while found1
      while (!found2)
      {
        found2 = true;
        while (i2 < tau2Ref->numberOfDaughters() )
        {
          reco::GenParticleRef childRef = tau2Ref->daughterRef(i2);
          std::cout << "\ttau2Ref child #" << i2 << " has pdgId= " << fabs(childRef->pdgId()) << std::endl;
          if (fabs(childRef->pdgId()) == 15)
          {
            tau2Ref = childRef->daughterRef(i2);
            found2 = false;
            break;
          }//if fabs
          if (fabs(childRef->pdgId()) == 13)
            tau2DecayMode = true;
          i2++;
        }//while i2
      }//while found2
    }//if
    else if(iGenParticle->pdgId() == 36 && iGenParticle->numberOfDaughters() == 2 && fabs(iGenParticle->daughter(0)->pdgId() ) == 13 )
    {
      mu1Ref = iGenParticle->daughterRef(0);
      mu2Ref = iGenParticle->daughterRef(1);
    }//if
  }//for

   double dPhiDiMu = reco::deltaPhi(mu1Ref->phi(), mu2Ref->phi()), dEtaDiMu = mu1Ref->eta() - mu2Ref->eta(), dRDiMu = sqrt(dPhiDiMu*dPhiDiMu + dEtaDiMu*dEtaDiMu);
   std::cout << " dRDiMu_Gen= " << dRDiMu << " \tsmallestDiMudR_RECO= " << smallestDiMudR << std::endl;
   DiMudR_->Fill(dRDiMu );
   //fill an STL container with muon ref keys
   std::vector<unsigned int> muonRefKeys;
   if (muons.isValid()) 
   {
     for (MuonRefVector::const_iterator iMuon = muons->begin(); iMuon != muons->end(); ++iMuon) 
       muonRefKeys.push_back(iMuon->key());
   }//if muons.isValid()

   //vector of bools holding the signal muon tag decision for each jet
   std::vector<bool> muonTagDecisions;

   //map between new jet and refs to muons in the original collection that were removed
   std::vector<MuonRefVector> removedMuonMap;

   //map between new jet and ref to original jet
   std::vector<PFJetRef> oldJets;

   std::vector<reco::PFJet> pfjetVector;
   for (PFJetCollection::const_iterator j = PFJets->begin(); j != PFJets->end(); ++j)
     pfjetVector.push_back(*j);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////// NOW DO THE JET-CLEANING /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   int PFCandMuons = 0;
   bool muonWasRemoved = false;
   int dNConst = 1000;
   for(reco::PFJetCollection::const_iterator iJet = PFJets->begin(); iJet != PFJets->end(); ++iJet)
   { // loop over jets
       std::vector<reco::PFCandidatePtr> JetPFCands = iJet->getPFConstituents();
       reco::PFJet::Specific specs = iJet->getSpecific();
       double jetEBefore = iJet->energy(), muEta = 1000, muE = -10;
       double jetMBefore=sqrt((iJet->energy())*(iJet->energy())-
                               (iJet->px())*(iJet->px())-
                               (iJet->py())*(iJet->py())-
                               (iJet->pz())*(iJet->pz()));
       unsigned int nConstBefore = JetPFCands.size();
       math::XYZTLorentzVector pfmomentum;
       std::vector<edm::Ptr<Candidate> > jetConstituents;
       jetConstituents.clear();

       //flag indicating whether >=0 muons were tagged for removal
       bool taggedMuonForRemoval = false;

       //vector of removed muons for this jet
       MuonRefVector removedMuons;

       for(std::vector<edm::Ptr<reco::PFCandidate> >::iterator i = JetPFCands.begin(); i != JetPFCands.end(); ++i)
       { // loop over PF candidates
	 reco::PFCandidate pfCand = *i;
	 /* Is the PF Candidate a muon? */
	 if (pfCand.particleId() == 3) //Reference: https://cmssdt.cern.ch/SDT/doxygen/CMSSW_7_1_17/doc/html/d8/d17/PFCandidate_8h_source.html
	 { // if it's a muon
	   // get the ref to the corresponding muon
	   // and count one more PF muon
	   reco::MuonRef theRecoMuon = pfCand.muonRef();
	   PFCandMuons += 1;
           //does this muon pass the desired muon ID?
 	   std::vector<unsigned int>::const_iterator iSoftMuon = std::find(muonRefKeys.begin(), muonRefKeys.end(), theRecoMuon.key());

	   //Comparing pfCand to Gen Level A_Mu's
           double dPhiMu1 = reco::deltaPhi(mu1Ref->phi(), pfCand.p4().phi()), dPhiMu2 = reco::deltaPhi(mu2Ref->phi(), pfCand.p4().phi());
    	   double dEtaMu1 = mu1Ref->eta() - pfCand.p4().eta(), dEtaMu2 = mu2Ref->eta() - pfCand.p4().eta();
	   double dRMu1 = sqrt(dPhiMu1*dPhiMu1 + dEtaMu1*dEtaMu1), dRMu2 = sqrt(dPhiMu2*dPhiMu2 + dEtaMu2*dEtaMu2);

	   //Comparing pfCand to Gen Level Tau's
           double dPhiTau1 = reco::deltaPhi(tau1Ref->phi(), pfCand.p4().phi()), dPhiTau2 = reco::deltaPhi(tau2Ref->phi(), pfCand.p4().phi());
           double dEtaTau1 = tau1Ref->eta() - pfCand.p4().eta(), dEtaTau2 = tau2Ref->eta() - pfCand.p4().eta();
	   double dRTau1 = sqrt(dPhiTau1*dPhiTau1 + dEtaTau1*dEtaTau1), dRTau2 = sqrt(dPhiTau2*dPhiTau2 + dEtaTau2*dEtaTau2);

           //Comparing pfCand to RECO smallestDiMudR
           double dPhiSmall1 = reco::deltaPhi(RecoMu1PairPhi, pfCand.p4().phi()), dPhiSmall2 = reco::deltaPhi(RecoMu2PairPhi, pfCand.p4().phi());
           double dEtaSmall1 = RecoMu1PairEta - pfCand.p4().eta(), dEtaSmall2 = RecoMu2PairEta - pfCand.p4().eta();
           double dRSmall1 = sqrt(dPhiSmall1*dPhiSmall1 + dEtaSmall1*dEtaSmall1), dRSmall2 = sqrt(dPhiSmall2*dPhiSmall2 + dEtaSmall2*dEtaSmall2);

	   double nearestMudR = 1000;
           for (vector<reco::Muon>::const_iterator iMuon = baseMuons->begin(); iMuon != baseMuons->end(); ++iMuon)
	   {
 	     double dPhiNearMu = reco::deltaPhi(iMuon->phi(), pfCand.p4().phi()), dEtaNearMu = iMuon->eta() - pfCand.p4().eta(), dRNearMu = sqrt(dPhiNearMu*dPhiNearMu + dEtaNearMu*dEtaNearMu);
	     std::cout << "TESTTESTTEST: dRNearMu= " << dRNearMu << std::endl;
  	     if (dRNearMu < nearestMudR && dRNearMu > .0001)
	       nearestMudR = dRNearMu;
	   }//for
	   std::cout << "\t\tdRMu1= " << dRMu1 << "  \tdRMu2= " << dRMu2 << "  \tnearestMudR= " << nearestMudR << "  \tdRTau1= " << dRTau1 << "  \tdRTau2= " << dRTau2
		     << "  \tdRSmall1= " << dRSmall1 << "  \tdRSmall2= " << dRSmall2 << std::endl;
	   if (dRMu1 < .01 && dRMu1 < dRMu2)
	   {
             MuEnergyA1_->Fill(pfCand.p4().e() );
	     AJetRemovedPt_->Fill(iJet->pt() - pfCand.p4().pt() );
             std::cout << "\t\t\tAMU: iJet->pt()= " << iJet->pt() << " \tpfCand.p4().pt()= " << pfCand.p4().pt();
	     std::cout << " \tiJet->pt() - pfCand.p4().pt()= " << iJet->pt() - pfCand.p4().pt()  << " \t1 - pfCand.p4().pt() / iJet->pt()= " << 1 - pfCand.p4().pt() / iJet->pt() << std::endl;
             AJetMuPt_->Fill(pfCand.p4().pt() );
	     AJetMuClosestMudR_->Fill(nearestMudR);
	     AJetRemovedPtFraction_->Fill(1 - pfCand.p4().pt() / iJet->pt() );
	   }//if
           else if (dRMu2 < .01 && dRMu2 < dRMu1)
	   {
             MuEnergyA1_->Fill(pfCand.p4().e() );	
	     AJetRemovedPt_->Fill(iJet->pt() - pfCand.p4().pt() );
             AJetMuPt_->Fill(pfCand.p4().pt() );
             std::cout << "\t\t\tAMU: iJet->pt()= " << iJet->pt() << " \tpfCand.p4().pt()= " << pfCand.p4().pt();
             std::cout << " \tiJet->pt() - pfCand.p4().pt()= " << iJet->pt() - pfCand.p4().pt()  << " \t1 - pfCand.p4().pt() / iJet->pt()= " << 1 - pfCand.p4().pt() / iJet->pt() << std::endl;
             AJetMuClosestMudR_->Fill(nearestMudR);
             AJetRemovedPtFraction_->Fill(1 - pfCand.p4().pt() / iJet->pt() );
	   }//else if
	   double ptFrac = pfCand.p4().pt() / iJet->pt();
	   if (iSoftMuon != muonRefKeys.end() && ( (dRTau1 > .01 && tau1DecayMode) || (dRTau2 > .01 && tau2DecayMode) ) )
	     NEvents_->Fill(1);
           if (iSoftMuon != muonRefKeys.end() && ( (dRTau1 > .01 && tau1DecayMode) || (dRTau2 > .01 && tau2DecayMode) ) && nearestMudR > .2 )
             NEvents_->Fill(2);
           if (iSoftMuon != muonRefKeys.end() && (dRMu1 < .01  || dRMu2 < .01 ) )
             NEvents_->Fill(3);
           if (iSoftMuon != muonRefKeys.end() && (dRMu1 < .01  || dRMu2 < .01 ) && nearestMudR > .2)
             NEvents_->Fill(4);
           if (iSoftMuon != muonRefKeys.end() && ( (dRTau1 > .01 && tau1DecayMode) || (dRTau2 > .01 && tau2DecayMode) ) && nearestMudR > .2 && ptFrac < .9)
             NEvents_->Fill(5);
           if (iSoftMuon != muonRefKeys.end() && (dRMu1 < .01  || dRMu2 < .01 ) && nearestMudR > .2 && ptFrac < .9)
             NEvents_->Fill(6);
           if (iSoftMuon != muonRefKeys.end() && smallestDiMudR < .6 && dRSmall1 > .01 && dRSmall2 > .01)
             NEvents_->Fill(7);
           if (iSoftMuon != muonRefKeys.end() && ( (dRTau1 > .01 && tau1DecayMode) || (dRTau2 > .01 && tau2DecayMode) ) && smallestDiMudR < .6 && dRSmall1 > .01 && dRSmall2 > .01)
             NEvents_->Fill(8);
           if (iSoftMuon != muonRefKeys.end() && (dRMu1 < .01  || dRMu2 < .01 ) && smallestDiMudR < .6 && dRSmall1 > .01 && dRSmall2 > .01)
             NEvents_->Fill(9);
           /*if we're not requiring gen matching but instead looking for muons in jets that pass the desired muon ID...*/	       
           if (iSoftMuon != muonRefKeys.end() && dRMu1 > .01 && dRMu2 > .01) 
    	   {
             muE = pfCand.p4().e();
             muEta = pfCand.p4().eta();
             specs.mMuonEnergy -= pfCand.p4().e();
             specs.mMuonMultiplicity -= 1;
               specs.mChargedMuEnergy -= pfCand.p4().e();
             specs.mChargedMultiplicity -= 1;
             //save tag decision for this muon
             taggedMuonForRemoval = true;
	     muonWasRemoved = true;
             /*add this muon ref to the vector of removed muons for this jet
                iSoftMuon - muonRefKeys.begin() is the index into muonRefKeys of the soft muon
                since muonRefKeys was filled in order of muons, it is also the index into 
                muons of the soft muon*/
	     removedMuons.push_back(muons->at(iSoftMuon - muonRefKeys.begin()));
	     TauJetRemovedPt_->Fill(iJet->pt() - pfCand.p4().pt() );
             TauJetMuPt_->Fill(pfCand.p4().pt() );
             std::cout << "\t\t\tTAU: iJet->pt()= " << iJet->pt() << " \tpfCand.p4().pt()= " << pfCand.p4().pt();
	     std::cout << " \tiJet->pt() - pfCand.p4().pt()= " << iJet->pt() - pfCand.p4().pt()  << " \t1 - pfCand.p4().pt() / iJet->pt()= " << 1 - pfCand.p4().pt() / iJet->pt() << std::endl;
             TauJetMuClosestMudR_->Fill(nearestMudR);
	     TauJetRemovedPtFraction_->Fill(1 - pfCand.p4().pt() / iJet->pt() );
	   }//if iSoftMuon
	   else
	   {//this muon doesn't pass the soft ID, so keep it in the jet
	     pfmomentum += pfCand.p4(); // total p4()
	     jetConstituents.push_back((*i));
	   }//else
	 }//if pfCand.particleId() == 3
	 else // if it's not a muon
	 { // get p4 and constituents
	   pfmomentum += pfCand.p4(); // total p4()
 	   jetConstituents.push_back((*i));
	 } //get p4 and constituents
       } // loop over PF candidates

       ////// Build a new jet without the muon /////////////

       PFJet muonfreePFJet(pfmomentum, specs, jetConstituents);
       SetOfJets->push_back( muonfreePFJet );

       //if at least 1 muon was tagged for removal, save a positive muon tag decision for this jet
       muonTagDecisions.push_back(taggedMuonForRemoval);
      //std::cout<<"muonTagDecisions.size"<<muonTagDecisions.size()<<std::endl;
       //save the ref vector of removed muons
       removedMuonMap.push_back(removedMuons);

       //ref to this (old) jet
       oldJets.push_back(PFJetRef(PFJets, iJet - PFJets->begin()));
      
       NMu_->Fill(PFCandMuons );
       if (taggedMuonForRemoval)
       {
         JetConstBeforevsAfter_->Fill(nConstBefore, jetConstituents.size());
         DiffJetEvsMuonE_->Fill(jetEBefore - muonfreePFJet.energy(), muE );
         JetEtavsMuEta_->Fill(iJet->eta(), muEta );
	 MuEnergy_->Fill(muE );
         JetMassBefore_->Fill(jetMBefore);
         //std::cout << "\tnConst: Before= " << nConstBefore << " \tjetConstituents.size= " << jetConstituents.size() << std::endl;
         //std::cout << "\tJetE  : Before= " << jetEBefore << " \tmuonfreePFJet= " << muonfreePFJet.energy() << " \tMuon E= " << muE << std::endl;
         //std::cout << "\tMuEta= " << muEta << " \tetiJet->eta()= " << iJet->eta() << std::endl;
	 dNConst = nConstBefore - jetConstituents.size();
         DiffConstituents_->Fill(dNConst );
       }
   } // loop over jets
  
   IfRemovedMu_->Fill(0);
   if (muonWasRemoved)
   {
     IfRemovedMu_->Fill(1); 
     if (dNConst != 0)
       IfRemovedMu_->Fill(2);
     if (dNConst == 1)
       IfRemovedMu_->Fill(3);
     if (dNConst == 2)
       IfRemovedMu_->Fill(4);
     if (dNConst == 3)
       IfRemovedMu_->Fill(5);
     std::cout << "A Muon Was Removed :)" << std::endl;
   }// if muonWasRemoved
   else 
     std::cout << "No Muon Was Removed :(" << std::endl;
   //fill an STL container of keys of removed muons
   std::vector<unsigned int> removedMuRefKeys;
   for (std::vector<MuonRefVector>::const_iterator iJet = removedMuonMap.begin(); iJet != removedMuonMap.end(); ++iJet) 
   {
     for (MuonRefVector::const_iterator iRemovedMu = iJet->begin(); iRemovedMu != iJet->end(); ++iRemovedMu) 
       removedMuRefKeys.push_back(iRemovedMu->key());

      // std::cout<<"removedMuRefKeys.size()"<<removedMuRefKeys.size()<<std::endl; 
   }//for iJet

   /*build a collection of PF candidates excluding soft muons
     we will still tag the jet as signal-like by the presence of a soft muon IN the jet, but this 
     ensures that such jets also cannot have the soft muon enter the isolation candidate 
     collection
     right now only remove muons that are inside jets; later expand to muons within dR = X.X of 
     the jets*/
   for (PFCandidateCollection::const_iterator iPFCand = PFCands->begin(); iPFCand != PFCands->end(); ++iPFCand) 
   {
     MuonRef removedMuRef = iPFCand->muonRef();
     if ((removedMuRef.isNonnull() && (std::find(removedMuRefKeys.begin(), removedMuRefKeys.end(), removedMuRef.key()) == removedMuRefKeys.end())) || removedMuRef.isNull()) 
       PFCandsExcludingSoftMuons->push_back(*iPFCand);
   }//for iPFCand
   //std::cout<<"PFCandsExcludingSoftMuons size"<<PFCandsExcludingSoftMuons->size()<<std::endl;
   const OrphanHandle<PFJetCollection> cleanedJetsRefProd = iEvent.put( SetOfJets, "ak4PFJetsNoMu"  );
  // std::cout<<"cleanedJEtsRefProd size"<<cleanedJetsRefProd->size()<<std::endl;
   //fill the value map of muon tag decision for each cleaned jet
   std::auto_ptr<edm::ValueMap<bool> > valMap(new edm::ValueMap<bool>());
   edm::ValueMap<bool>::Filler filler(*valMap);
   filler.insert(cleanedJetsRefProd, muonTagDecisions.begin(), muonTagDecisions.end());
   filler.fill();
   iEvent.put(valMap, "valMap");
   //fill the value map of removed muon refs for each cleaned jet
   std::auto_ptr<edm::ValueMap<MuonRefVector> > muonValMap(new edm::ValueMap<MuonRefVector>());
   edm::ValueMap<MuonRefVector>::Filler muonFiller(*muonValMap);
   muonFiller.insert(cleanedJetsRefProd, removedMuonMap.begin(), removedMuonMap.end());
   muonFiller.fill();
   iEvent.put(muonValMap );

   //fill the value map of old jet refs for each cleaned jet
   std::auto_ptr<edm::ValueMap<PFJetRef> > jetValMap(new edm::ValueMap<PFJetRef>());
   edm::ValueMap<PFJetRef>::Filler jetFiller(*jetValMap);
   jetFiller.insert(cleanedJetsRefProd, oldJets.begin(), oldJets.end());
   jetFiller.fill();
   iEvent.put(jetValMap );

   //put the soft-muon-free PF cands into the event
   iEvent.put(PFCandsExcludingSoftMuons);
}

// ------------ method called once each job just before starting event loop  ------------
void 
CleanJets::beginJob()
{
  if (debug_) out_ = new TFile(outFileName_.c_str(), "RECREATE");

  NEvents_= new TH1F("NEvents", "", 10, -.5, 9.5);
      NEvents_->GetXaxis()->SetBinLabel(1, "TotalEvents");
      NEvents_->GetXaxis()->SetBinLabel(2, "#tau_{#mu}");
      NEvents_->GetXaxis()->SetBinLabel(3, "#tau_{#mu}, #DeltaR nearest #mu check");
      NEvents_->GetXaxis()->SetBinLabel(4, "a_{#mu}");
      NEvents_->GetXaxis()->SetBinLabel(5, "a_{#mu}, #DeltaR nearest #mu check");
      NEvents_->GetXaxis()->SetBinLabel(6, "#tau_{#mu}, #DeltaR, p_{T} Frac < .9");
      NEvents_->GetXaxis()->SetBinLabel(7, "a_{#mu}, #DeltaR,  p_{T} Frac < .9");
      NEvents_->GetXaxis()->SetBinLabel(8, "RECO #DeltaR smallest #mu check");
      NEvents_->GetXaxis()->SetBinLabel(9, "#tau_{#mu}, #DeltaR smallest #mu check");
      NEvents_->GetXaxis()->SetBinLabel(10, "a_{#mu}, #DeltaR smallest #mu check");
  DiMudR_= new TH1F("DiMudR", ";Number of muons;", 100, 0, 6);
  NMu_= new TH1F("NMu", ";Number of muons;", 7, -.5, 6.5);
  MuEnergy_= new TH1F("MuEnergy", ";Muon p_{T} (GeV);", 50, -.5, 100);
  MuEnergyA1_= new TH1F("MuEnergyA1", ";A1->Muon p_{T} (GeV);", 50, -.5, 100);
  DiffJetEvsMuonE_ = new TH2F("DiffJetEvsMuonE", ";E_{uncleaned jet} - E_{cleaned jet} (GeV);E_{#mu} (GeV)", 50, 0, 50, 50, 0, 50);
  JetEtavsMuEta_ = new TH2F("JetEtavsMuEta", ";#eta_{jet};#eta_{#mu}", 20, -5, 5, 20, -5, 5);
  JetConstBeforevsAfter_ = new TH2F("JetConstBeforevsAfter",  ";No. uncleaned jet constituents;No. cleaned jet constituents", 20, 0, 20, 20, 0, 20);
  DiffConstituents_= new TH1F("DiffConstituents", ";N_{const}(uncleaned) - N_{const}(cleaned);", 8, -1.5, 6.5);
  JetMassBefore_=new TH1F("JetMassBeforeCleanMuon","JetMassBefore",100,0,50);
  IfRemovedMu_=new TH1F("IfRemovedMuCleanMuon","IfRemovedMu", 6, -.5, 5.5);
      IfRemovedMu_->GetXaxis()->SetBinLabel(1, "TotalEvents");
      IfRemovedMu_->GetXaxis()->SetBinLabel(2, "RemovedMu");
      IfRemovedMu_->GetXaxis()->SetBinLabel(3, "RemovedMu, #DeltanConst != 0");
      IfRemovedMu_->GetXaxis()->SetBinLabel(4, "RemovedMu, #DeltanConst == 1");
      IfRemovedMu_->GetXaxis()->SetBinLabel(5, "RemovedMu, #DeltanConst == 2");
      IfRemovedMu_->GetXaxis()->SetBinLabel(6, "RemovedMu, #DeltanConst == 3");
  TauJetRemovedPt_=new TH1F("TauJetRemovedPtCleanMuon","TauJetRemovedPt", 50, 0, 400);
  AJetRemovedPt_=new TH1F("AJetRemovedPtCleanMuon","AJetRemovedPt", 50, 0, 400);
  TauJetMuPt_=new TH1F("TauJetMuPtCleanMuon","TauJetMuPt", 50, 0, 400);
  AJetMuPt_=new TH1F("AJetMuPtCleanMuon","AJetMuPt", 50, 0, 400);
  TauJetMuClosestMudR_=new TH1F("TauJetMuClosestMudRCleanMuon","TauJetMuClosestMudR", 100, 0, 6);
  AJetMuClosestMudR_=new TH1F("AJetMuClosestMudRCleanMuon","AJetMuClosestMudR", 100, 0, 6);
  TauJetRemovedPtFraction_=new TH1F("TauJetRemovedPtFractionCleanMuon","TauJetRemovedPtFraction", 25, 0, 1);
  AJetRemovedPtFraction_=new TH1F("AJetRemovedPtFractionCleanMuon","AJetRemovedPtFraction", 25, 0, 1);
  
}

// ------------ method called once each job just after ending the event loop  ------------
void 
CleanJets::endJob()
{

  if (debug_) {

    out_->cd();

    TCanvas NEventsCanvas_("NEventsCanvas","",600,600);
    TCanvas DiMudRCanvas_("DiMudRCanvas","",600,600);
    TCanvas NMuCanvas_("NMuCanvas","",600,600);
    TCanvas MuEnergyCanvas_("MuEnergyCanvas","",600,600);
    TCanvas MuEnergyA1Canvas_("MuEnergyA1Canvas","",600,600);
    TCanvas DiffJetEvsMuonECanvas_("DiffJetEvsMuonECanvas","",600,600);
    TCanvas JetEtavsMuEtaCanvas_("JetEtavsMuEtaCanvas","",600,600);
    TCanvas JetConstBeforevsAfterCanvas_("JetConstBeforevsAfterCanvas","",600,600);
    TCanvas DiffConstituentsCanvas_("DiffConstituentsCanvas","",600,600);
    TCanvas JetMassBeforeCanvas_("JetMassBefore","",600,600);
    TCanvas IfRemovedMuCanvas_("IfRemovedMu","",600,600);
    TCanvas TauJetRemovedPtCanvas_("TauJetRemovedPt","",600,600);
    TCanvas AJetRemovedPtCanvas_("AJetRemovedPt","",600,600);
    TCanvas TauJetMuPtCanvas_("TauJetMuPt","",600,600);
    TCanvas AJetMuPtCanvas_("AJetMuPt","",600,600);
    TCanvas TauJetMuClosestMudRCanvas_("TauJetMuClosestMudR","",600,600);
    TCanvas AJetMuClosestMudRCanvas_("AJetMuClosestMudR","",600,600);
    TCanvas TauJetRemovedPtFractionCanvas_("TauJetRemovedPtFraction","",600,600);
    TCanvas AJetRemovedPtFractionCanvas_("AJetRemovedPtFraction","",600,600);

    Common::draw1DHistograms(NEventsCanvas_, NEvents_);
    Common::draw1DHistograms(DiMudRCanvas_, DiMudR_);
    Common::draw1DHistograms(NMuCanvas_, NMu_);
    Common::draw1DHistograms(MuEnergyCanvas_, MuEnergy_);
    Common::draw1DHistograms(MuEnergyA1Canvas_, MuEnergyA1_);
    Common::draw1DHistograms(DiffConstituentsCanvas_, DiffConstituents_);
    Common::draw2DHistograms(DiffJetEvsMuonECanvas_, DiffJetEvsMuonE_);
    Common::draw2DHistograms(JetEtavsMuEtaCanvas_, JetEtavsMuEta_);
    Common::draw2DHistograms(JetConstBeforevsAfterCanvas_, JetConstBeforevsAfter_);
    Common::draw1DHistograms(JetMassBeforeCanvas_, JetMassBefore_);
    Common::draw1DHistograms(IfRemovedMuCanvas_, IfRemovedMu_);
    Common::draw1DHistograms(TauJetRemovedPtCanvas_, TauJetRemovedPt_);
    Common::draw1DHistograms(AJetRemovedPtCanvas_, AJetRemovedPt_);
    Common::draw1DHistograms(TauJetMuPtCanvas_, TauJetMuPt_);
    Common::draw1DHistograms(AJetMuPtCanvas_, AJetMuPt_);
    Common::draw1DHistograms(TauJetMuClosestMudRCanvas_, TauJetMuClosestMudR_);
    Common::draw1DHistograms(AJetMuClosestMudRCanvas_, AJetMuClosestMudR_);
    Common::draw1DHistograms(TauJetRemovedPtFractionCanvas_, TauJetRemovedPtFraction_);
    Common::draw1DHistograms(AJetRemovedPtFractionCanvas_, AJetRemovedPtFraction_);
    
    NEventsCanvas_.Write();
    DiMudRCanvas_.Write();
    NMuCanvas_.Write();
    MuEnergyCanvas_.Write();
    MuEnergyA1Canvas_.Write();
    DiffJetEvsMuonECanvas_.Write();
    JetEtavsMuEtaCanvas_.Write();
    JetConstBeforevsAfterCanvas_.Write();
    DiffConstituentsCanvas_.Write();
    JetMassBeforeCanvas_.Write();
    IfRemovedMuCanvas_.Write();
    TauJetRemovedPtCanvas_.Write();
    AJetRemovedPtCanvas_.Write();
    TauJetMuPtCanvas_.Write();
    AJetMuPtCanvas_.Write();
    TauJetMuClosestMudRCanvas_.Write();
    AJetMuClosestMudRCanvas_.Write();
    TauJetRemovedPtFractionCanvas_.Write();
    AJetRemovedPtFractionCanvas_.Write();

    out_->Write();
    out_->Close();

  }

}

// ------------ method called when starting to processes a run  ------------
void 
CleanJets::beginRun(edm::Run&, edm::EventSetup const&)
{
}

// ------------ method called when ending the processing of a run  ------------
void 
CleanJets::endRun(edm::Run&, edm::EventSetup const&)
{
}

// ------------ method called when starting to processes a luminosity block  ------------
void 
CleanJets::beginLuminosityBlock(edm::LuminosityBlock&, edm::EventSetup const&)
{
}

// ------------ method called when ending the processing of a luminosity block  ------------
void 
CleanJets::endLuminosityBlock(edm::LuminosityBlock&, edm::EventSetup const&)
{
}

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
CleanJets::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(CleanJets);
